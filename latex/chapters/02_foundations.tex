\section{Theoretische und technische Grundlagen}

\subsection{Datenstrukturen}
\subsubsection{Graph}
Um das kürzeste-Wege-Problem zu lösen, muss zunächst das reale Straßennetz in eine abstrakte Form
gebracht werden. Hierzu wird das Straßennetz als Graph modelliert. Ein Graph $G = (V,E)$ besteht aus
einer Menge von Knoten V und einer Menge von Kanten E. Jede Kante $e = (u,v)\in E$ verbindet zwei
Knoten $u,v \in V$. Knoten bilden Kreuzungen ab und Kanten Straßensegmente zwischen zwei Kreuzungen.
Ein Graph kann als gerichtet oder ungerichtet definiert werden. Bei einem ungerichteten  Graphen
sind die Kanten bidirektional und können in beide Richtungen durchlaufen werden, während bei einem
gerichteten Graphen die Kanten nur in eine Richtung durchlaufen werden können.\\

Der Graph in dieser Arbeit ist gerichtet und gewichtet. Die Kantenrichtung spiegelt dabei die
Richtung des Verkehrs wieder, \dH sie gibt an, ob eine Straße in einer bestimmten Richtung befahren
werden darf oder nicht. Zusätzlich wird für jede Kante ein Gewicht $w(e)$ festgelegt. In diesem Fall
wird die durchscnittliche Zeit $t = \frac{V}{S}$ in Sekunden verwendet, die  sich aus der Länge des
Straßensegments \emph{S} und der maximal erlaubten Geschwindigkeit \emph{V} auf dieser Straße berechnet. Der
kürzeste Weg zwischen zwei Knoten ist damit der Weg mit der minimalen Zeit.\\

Es gibt generell zwei Möglichkeiten, einen Graphen als Datenstruktur darzustellen. Eine davon ist
die Verwendung von Adjazenzlisten. Dabei wird für jeden Knoten $u \in V$ eine Liste der benachbarten
Knoten bzw. ausgehenden Kanten $e(u,v) \in E$ gespeichert. Die Summe der Länge aller Adjazenzlisten
in einem gerichteten Graph ist $|E|$, bzw. $2|E|$ in einem ungerichteten Graph. Der
Speicherverbrauch für die Adjazenzliste ist damit $\Theta(|V| + |E|)$ \cite{intro.algo}.

Die zweite Möglichkeit ist die Verwendung einer Adjazenzmatrix. Hier wird eine zweidimensionale
Matrix der Größe $|V| \times |V|$ verwendet, bei der die Zeilen und Spalten den Knoten entsprechen.
Der Eintrag an Position $(i,j)$ in der Matrix gibt an, ob eine Kante zwischen den Knoten $i$ und $j$
existiert. Unabhängig von der Anzahl an Kanten ist der Speicherverbrauch $\Theta(|V|^2)$
\cite{intro.algo}. Ein Beispiel für beide Darstellungen anhand eines einfachen Graph befindet sich
in Abbildung~\ref{fig:graph_ex1}.\\

Für diese Arbeit werden Adjazenzlisten verwendet, da zum einen Straßennetze dünne Graphen sind ($|E|
    << |V|^2$), und damit die Speichereffizienz gegenüber einer Adjazenzmatrix deutlich effizienter
ist. Zum anderen ist für es wichtig, für den Aufbau der \ac{CHs} und der Suche, schnell auf alle
Nachbarn eines Knotens zuzugreifen zu können. Der Zugriff auf
eingehende Kanten ist allerding nur sehr aufwendig  möglich, wird  aber für den Aufbau der
Kontraktionshierarchien benötigt. Das Problem lässt sich jedoch lösen indem auch
Adjazenzlisten für alle eingehenden Kanten eines Knotens angelegt werden. Damit erhöht sich der
Speicherverbrauch auf $\Theta(|V| + 2|E|)$, was aber immer noch deutlich effizienter ist als
eine Darstellung als Adjazenzmatrix.\todo{Ref genaue Datenstruktur?}

\begin{figure}[H]
    \centering
    \begin{subfigure}{1.0\textwidth}
        \centering
        \begin{tikzpicture}
            \Vertices[color=gray!90!blue]{data/graphs/ex1/vertices.csv}
            \Edges{data/graphs/ex1/edges.csv}
        \end{tikzpicture}
        \caption{}
    \end{subfigure}
    \\[3ex]
    \begin{subfigure}[b]{0.3\textwidth}
        \centering
        \begin{blockarray}{c|ccccc}
            & A & B & C & D & E \\
            \BAhline
            \begin{block}{c|ccccc}
                A &0 & 3 & 5 & 0 & 3 \\
                B &3 & 0 & 3 & 0 & 0 \\
                C &0 & 0 & 0 & 2 & 0 \\
                D &0 & 0 & 2 & 0 & 3 \\
                E &3 & 0 & 0 & 3 & 0 \\
            \end{block}
        \end{blockarray} \
        \caption{}
    \end{subfigure}
    \hspace{3em}
    \begin{subfigure}[b]{0.3\textwidth}
        \centering
        \begin{tikzpicture}[
                node distance = 21mm and 7mm,
                box/.style = {draw, minimum size=5mm, inner sep=0pt, outer sep=0pt, anchor=west},
                pin edge = {Straight Barb-, shorten <=1mm,semithick}
            ]
            \matrix (mat1) [matrix of nodes,
                nodes={box},
                align=left,
                column sep=-\pgflinewidth,
                inner sep=0pt,
                pin=180:A
            ]
            {
                B & C & E \\
            };
            \matrix (mat2) [matrix of nodes,
                below=1.5em of mat1-1-1.west,
                anchor=west,
                nodes={box},
                column sep=-\pgflinewidth,
                inner sep=0pt,
                pin=180:B
            ]
            {
                A & C \\
            };
            \matrix (mat3) [matrix of nodes,
                below=1.5em of mat2-1-1.west,
                anchor=west,
                nodes={box},
                column sep=-\pgflinewidth,
                inner sep=0pt,
                pin=180:C
            ]
            {
                D \\
            };
            \matrix (mat4) [matrix of nodes,
                below=1.5em of mat3-1-1.west,
                anchor=west,
                nodes={box},
                column sep=-\pgflinewidth,
                inner sep=0pt,
                pin=180:D
            ]
            {
                C & E \\
            };
            \matrix (mat5) [matrix of nodes,
                below=1.5em of mat4-1-1.west,
                anchor=west,
                nodes={box},
                column sep=-\pgflinewidth,
                inner sep=0pt,
                pin=180:E
            ]
            {
                A & D \\
            };
        \end{tikzpicture}
        \vspace{1em}
        \caption{}
    \end{subfigure}
    \caption{Der oben gezeigte gerichtete Graph (a) dargestellt als Adjazenzmatrix(b) oder
        Adjazenzliste (c).}
    \label{fig:graph_ex1}
\end{figure}

\subsubsection{Vorrangwarteschlangen}
Eine \ac{PQ} ist eine Datenstruktur, in der nur auf das Element mit der höchsten Priorität
zugegriffen werden kann. Eine \ac{PQ} unterstützt in der Regel die folgenden Operationen:
\begin{enumerate}
    \item Einfügen (Push): Ein Element wird mit seiner zugehörigen Priorität in die Warteschlange
          eingefügt. Das Element wird entsprechend seiner Priorität platziert.
    \item Entfernen (Pop): Das Element mit der aktuell höchsten Priorität wird aus der Warteschlange
          entfernt und zurückgegeben.
\end{enumerate}
\ac{PQ}s werden allen nachfolgenden Suchalgorithmen verwendet, daher hat die Implementierung der
Warteschlange einen großen Einfluss auf die Laufzeit der Algorithmen. In der Arbeit wird die
Implementierung als binärern Min-Heap verwendet mit einer Zeitkompexität für das Einfügen von
$\theta(1)\sim$ und für das Entfernen von $\theta(\log n)$.

\subsection{Kürzeste-Wege-Algorithmen}
Haha das ist doch wahnsinn

\subsubsection{Grundlegende Technik}
\subsubsection{Zielorientiert}
\subsubsection{Hierarchisch}

\subsection{OpenStreetMap}